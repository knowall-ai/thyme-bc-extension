name: Deploy to Sandbox (Contoso)

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: windows-latest
    environment: Sandbox

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install BcContainerHelper
        shell: powershell
        run: |
          Install-Module BcContainerHelper -Force -AllowClobber
          Import-Module BcContainerHelper

      - name: Build and Deploy to Sandbox
        shell: powershell
        env:
          BC_TENANT_ID: ${{ secrets.BC_TENANT_ID }}
          BC_CLIENT_ID: ${{ secrets.BC_CLIENT_ID }}
          BC_CLIENT_SECRET: ${{ secrets.BC_CLIENT_SECRET }}
        run: |
          # Get OAuth token directly with correct resource for BC API
          # Using v1.0 endpoint with resource parameter (required for BC Online)
          $tokenUrl = "https://login.microsoftonline.com/$($env:BC_TENANT_ID)/oauth2/token"
          $tokenBody = @{
            client_id = $env:BC_CLIENT_ID
            client_secret = $env:BC_CLIENT_SECRET
            resource = "https://api.businesscentral.dynamics.com"
            grant_type = "client_credentials"
          }

          Write-Host "Getting OAuth token..."
          try {
            $tokenResponse = Invoke-RestMethod -Uri $tokenUrl -Method Post -Body $tokenBody -ContentType "application/x-www-form-urlencoded"
            $accessToken = $tokenResponse.access_token
            Write-Host "Got access token (first 50 chars): $($accessToken.Substring(0, 50))..."

            # Decode JWT to see claims (for debugging)
            $tokenParts = $accessToken.Split('.')
            $payload = $tokenParts[1]
            # Add padding if needed
            $padding = 4 - ($payload.Length % 4)
            if ($padding -ne 4) { $payload += '=' * $padding }
            $decodedPayload = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($payload))
            $claims = $decodedPayload | ConvertFrom-Json
            Write-Host "Token audience (aud): $($claims.aud)"
            Write-Host "Token app ID (appid): $($claims.appid)"
            Write-Host "Token roles: $($claims.roles -join ', ')"
            Write-Host "Token tenant (tid): $($claims.tid)"
          } catch {
            Write-Host "Token Error: $($_.Exception.Message)"
            $errorBody = $_.ErrorDetails.Message
            Write-Host "Error Details: $errorBody"
            throw
          }

          Write-Host "Authenticated successfully"

          # Get the BC Online environment info to determine correct artifact version
          $environmentUrl = "https://api.businesscentral.dynamics.com/v2.0/$($env:BC_TENANT_ID)/Sandbox"

          # Get sandbox artifact matching BC Online version
          $artifactUrl = Get-BCArtifactUrl -type Sandbox -country us -select Latest
          Write-Host "Using artifact: $artifactUrl"

          # Create compiler folder from artifacts
          $compilerFolder = New-BcCompilerFolder -artifactUrl $artifactUrl -cacheFolder "c:\bccompiler"
          Write-Host "Compiler folder: $compilerFolder"

          # Find alc.exe in the compiler folder
          $alcExe = Join-Path $compilerFolder "extension\bin\win32\alc.exe"
          if (-not (Test-Path $alcExe)) {
            $alcExe = Join-Path $compilerFolder "extension\bin\alc.exe"
          }
          if (-not (Test-Path $alcExe)) {
            # Search recursively
            $alcExe = (Get-ChildItem -Path $compilerFolder -Filter "alc.exe" -Recurse | Select-Object -First 1).FullName
          }
          Write-Host "ALC path: $alcExe"

          # Get symbols from the compiler folder
          $symbolsFolder = Join-Path $compilerFolder "symbols"
          Write-Host "Symbols folder: $symbolsFolder"
          Get-ChildItem $symbolsFolder -Filter "*.app" | ForEach-Object { Write-Host "  - $($_.Name)" }

          # Create output folder
          $outputFolder = Join-Path $env:GITHUB_WORKSPACE "output"
          New-Item -ItemType Directory -Path $outputFolder -Force | Out-Null

          # Compile the app
          Write-Host "Compiling app..."
          $appJsonPath = Join-Path $env:GITHUB_WORKSPACE "app.json"
          $appJson = Get-Content $appJsonPath | ConvertFrom-Json
          $appFileName = "$($appJson.publisher)_$($appJson.name)_$($appJson.version).app"
          $appFilePath = Join-Path $outputFolder $appFileName

          & $alcExe /project:$env:GITHUB_WORKSPACE /packagecachepath:$symbolsFolder /out:$appFilePath /assemblyprobingpaths:$compilerFolder

          if (Test-Path $appFilePath) {
            Write-Host "Built app: $appFilePath"
          } else {
            Write-Host "Looking for any .app file in output..."
            Get-ChildItem $outputFolder
            throw "Failed to compile app"
          }

          # Deploy to Sandbox using REST API directly (BcContainerHelper has tenant URL bug)
          Write-Host "Publishing to Sandbox..."

          $automationApiUrl = "https://api.businesscentral.dynamics.com/v2.0/$($env:BC_TENANT_ID)/Sandbox/api/microsoft/automation/v2.0"
          Write-Host "Automation API URL: $automationApiUrl"

          $headers = @{
            "Authorization" = "Bearer $accessToken"
            "Content-Type" = "application/json"
          }

          # First test: Try standard BC API to verify token works
          $standardApiUrl = "https://api.businesscentral.dynamics.com/v2.0/$($env:BC_TENANT_ID)/Sandbox/api/v2.0"
          Write-Host "Testing standard BC API: $standardApiUrl/companies"
          try {
            $testResponse = Invoke-RestMethod -Uri "$standardApiUrl/companies" -Headers $headers -Method Get
            Write-Host "Standard API works! Found $($testResponse.value.Count) companies"
          } catch {
            Write-Host "Standard API also fails: $($_.Exception.Message)"
            if ($_.Exception.Response) {
              $errorStream = $_.Exception.Response.GetResponseStream()
              $reader = New-Object System.IO.StreamReader($errorStream)
              Write-Host "Standard API Error: $($reader.ReadToEnd())"
            }
          }

          # Get companies via Automation API
          Write-Host "Getting companies via Automation API..."
          try {
            $companiesResponse = Invoke-RestMethod -Uri "$automationApiUrl/companies" -Headers $headers -Method Get
            $company = $companiesResponse.value | Select-Object -First 1
            Write-Host "Using company: $($company.name) ($($company.id))"
          } catch {
            Write-Host "Companies API Error: $($_.Exception.Message)"
            Write-Host "Status Code: $($_.Exception.Response.StatusCode.value__)"
            $errorStream = $_.Exception.Response.GetResponseStream()
            $reader = New-Object System.IO.StreamReader($errorStream)
            $errorBody = $reader.ReadToEnd()
            Write-Host "Error Body: $errorBody"
            Write-Host ""
            Write-Host "=== TROUBLESHOOTING ==="
            Write-Host "The token is valid but BC rejected it. Please verify in BC Admin Center:"
            Write-Host "1. Go to https://businesscentral.dynamics.com/admin"
            Write-Host "2. Click 'Microsoft Entra Apps' in the left sidebar"
            Write-Host "3. Verify your app is listed and shows 'Authorized' status"
            Write-Host "4. If you see a 'Grant' link, click it to complete authorization"
            Write-Host "========================"
            throw
          }

          # Upload extension (3-step process per Microsoft docs)
          Write-Host "Uploading extension..."
          $appBytes = [System.IO.File]::ReadAllBytes($appFilePath)

          # Step 1: Create extensionUpload object
          Write-Host "Step 1: Creating extensionUpload object..."
          $createBody = @{
            "schedule" = "Current version"
            "schemaSyncMode" = "Add"
          } | ConvertTo-Json

          $createHeaders = @{
            "Authorization" = "Bearer $accessToken"
            "Content-Type" = "application/json"
          }

          $extensionUploadUrl = "$automationApiUrl/companies($($company.id))/extensionUpload"
          Write-Host "Create URL: $extensionUploadUrl"
          Write-Host "Create Body: $createBody"

          try {
            $uploadObject = Invoke-RestMethod -Uri $extensionUploadUrl -Headers $createHeaders -Method Post -Body $createBody
            $uploadId = $uploadObject.systemId
            Write-Host "Created extensionUpload with ID: $uploadId"
          } catch {
            Write-Host "Step 1 Error: $($_.Exception.Message)"
            if ($_.Exception.Response) {
              $errorStream = $_.Exception.Response.GetResponseStream()
              $reader = New-Object System.IO.StreamReader($errorStream)
              $errorBody = $reader.ReadToEnd()
              Write-Host "Step 1 Error Body: $errorBody"
            }
            throw
          }

          # Step 2: Upload the actual .app file content
          Write-Host "Step 2: Uploading .app file content..."
          $contentHeaders = @{
            "Authorization" = "Bearer $accessToken"
            "Content-Type" = "application/octet-stream"
            "If-Match" = "*"
          }

          $contentUrl = "$automationApiUrl/companies($($company.id))/extensionUpload($uploadId)/extensionContent"
          Write-Host "Content URL: $contentUrl"

          Invoke-RestMethod -Uri $contentUrl -Headers $contentHeaders -Method Patch -Body $appBytes
          Write-Host "File uploaded successfully"

          # Step 3: Trigger the installation
          Write-Host "Step 3: Triggering installation..."
          $installHeaders = @{
            "Authorization" = "Bearer $accessToken"
          }

          $installUrl = "$automationApiUrl/companies($($company.id))/extensionUpload($uploadId)/Microsoft.NAV.upload"
          Write-Host "Install URL: $installUrl"

          try {
            Invoke-RestMethod -Uri $installUrl -Headers $installHeaders -Method Post
            Write-Host "Deployed to Sandbox successfully!"
          } catch {
            Write-Host "Installation Error: $($_.Exception.Message)"
            if ($_.Exception.Response) {
              $errorStream = $_.Exception.Response.GetResponseStream()
              $reader = New-Object System.IO.StreamReader($errorStream)
              $errorBody = $reader.ReadToEnd()
              Write-Host "Error Body: $errorBody"
            }
            throw
          }

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: thyme-bc-extension-sandbox
          path: 'output/*.app'
          if-no-files-found: warn
